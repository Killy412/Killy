---
title: 深入理解JVM虚拟机-内存
date: 2021-01-30 10:47:53
tags:
  - "JVM"
  - "内存详解"
categories: "JVM"
---

## 运行时数据区域

### 程序计数器

(PC Register),记录当前线程执行程序的位置,改变计数器的值确定下一条执行的指令,线程私有.
程序计数器是唯一不会出现 `OOM` 情况的内存区域

### Java 虚拟机栈

线程私有.虚拟机栈描述的是 Java 方法执行的线程内存模型.每个方法被执行的时候,Java 虚拟机都会同步创建一个栈帧(Stack Frame),用于存储局部变量表/操作数栈/动态连接/方法出口等信息.每个方法在被调用到执行完毕的过程,就对应一个栈帧在虚拟机栈中入栈到出栈的过程.

Java8 局部变量表中只有基本类型变量,引用类型只存储引用地址.
Java 虚拟机栈中可能出现两种错误

- `StackOverflowError`: 调用栈深度大于 Java 虚拟机栈的最大深度的时候会爆出
- `OutOfMemoryError`: 内存溢出

### 本地方法栈

本地方法栈和虚拟机栈作用类似,区别是虚拟机栈为虚拟机执行 Java 方法服务,本地方法栈为虚拟机使用的 navicat 方法服务.
在 HotSpot 中本地方法栈和虚拟机栈一样的.也会爆出`StackOverflowError`和`OutofMemoryError`错误

### 堆

堆是 Java 运行时最大的一块内存区域.所有创建的对象实例以及数组对象都放在堆中.并且是所有线程共享的.
从垃圾回收的角度,堆还可以分为新生代和老年代.新生代包含 `edan` 区和两个`surivor`区.

堆内存最容易出现 OOM 错误.

### 方法区

方法区主要存储加载的类信息,静态变量,常量. 占用的是本地内存. 方法区也被称为永久代.
方法区和永久代的区别,永久代是 HotSpot 对方法区的实现.方法区是<JVM 虚拟机规范>一书中的逻辑定义.
在 jdk1.8 方法区被移除,替代的是元空间.

### 运行时常量池

运行时常量池是方法区的一部分. Class 文件中除了有属性代码定义等描述信息之外,还有常量池表,用于存放编译时生成的字面量和符号引用,这部分内存在类加载后存放在常量池中.
jdk1.8 中,运行时常量池在方法区中,也就是元空间.字符串常量池在堆中.

### 直接内存

直接内存不是运行时数据区域的一部分.也不是 jvm 虚拟机规范中定义的任何部分.但是这部分内存也被频繁使用.而且可能导致 OOM 错误.
Java1.4 中新加入的 NIO,引用了一种基于通道和缓存的方式.可以使用 native 库直接分配堆外内存,然后通过`DirectByteBuffer`对象来进行操作. 这样可以在一些场景中提升性能,避免了在 Java 堆和 native 堆来回复制数据.

## 虚拟机对象探秘

### 对象的创建

1. 遇到 new 指令,首先检查指令的参数能否在常量池中定位到这个类的符号引用,并且检查类是否已经被加载.如果没有,则先执行类加载流程.

2. 为对象分配内存,对象所需内存大小在类加载完成阶段已经确认.

   **分配内存有两种方式,具体使用哪种根据内存是否规整来决定.而内存是否规整根据使用的垃圾收集器是否带有压缩整理功能决定.**

- 指针碰撞: 主要用于内存规整的情况.有一个指针,指向已使用内存和未使用内存的分界地址. 分配的时候指针向右移动所需内存大小的位置就可以.
- 空闲列表: 用于内存不规整的情况. 虚拟机会维护一个未使用的内存列表,分配的时候找到一个容量合适的内存块划分给对象.

> 创建对象分配内存时有线程安全的问题,当正在给对象 A 分配内存,指针还没来得及修改,对象 B 又同时使用了原来的指针来分配内存.虚拟机有两种方式保证线程安全.
>
> - CAS+失败重试机制.保证分配内存的安全性
> - TLAB:为每个线程分配一个本地线程分配缓冲(Thread Local Allocation Buffer),每个线程先在被分配的内存块中分配,使用完之后再使用上面 CAS 方式进行分配.

3. 初始化零值. 内存分配完成后,需要将分配到的内存空间初始化为零值. 保证对象属性在没有设置的情况下可以使用零值.

4. 设置对象头,设置一些必要的东西,例如对象所属类型,gc 年龄,哈希码等信息.

5. 执行<init> 方法. 上面步骤完成之后,从 jvm 角度看一个对象已经创建好,从 java 程序看对象创建刚开始,执行<init>方法之后一个对象才真正创建好.

### 对象的内存布局

对象在 HotSpot 虚拟机中,主要分为三个部分

- 对象头: 包含两部分
  1. Mark World: 包含 GC 年龄,hash 值,偏向线程 id,锁状态标识等.
  2. 类型指针: 确认对象所属的类型.
- 实例数据: 存储对象真正使用的数据,属性等信息.
- 对其补充:因为 HotSpot 要求对象的起始地址必须是 8 字节的整倍数,所以当对象实例数据没有对齐时,需要使用对齐填充来对齐.

### 对象的访问定位

两种方式

- 直接访问: 栈中 reference 变量指向堆中实例数据,实例数据保存了对象的类型指针.如果只访问对象本身数据,少了一次定位开销.
- 句柄池访问: 堆中有一个句柄池,reference 变量指向句柄池的句柄地址,句柄保存了对象的类型指针和实例指针.
